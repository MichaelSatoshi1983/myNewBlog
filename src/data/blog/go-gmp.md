---
title: "从 GMP 模型读懂并发的优雅"
date: "2025-07-04 00:28:33"
pubDatetime: 2025-07-04 00:28:33
description: "介绍了 Go 语言中 context 包的设计原理与实现机制 "
tags: ["Go 牛逼之路"]
---
# 一、引言

Go 语言在云计算和分布式系统这块儿用得特别多，算是首选之一，它的并发处理能力是最大的优点。跟以前的线程处理方式不一样，Go 有自己独特的 GMP  模型 —— 也就是 Goroutine、Machine、Processor 这三个部分 —— 能提供高效又轻便的并发编程体验。有了这个 GMP  模型，开发者能轻松弄出成千上万的并发任务，也就是 goroutine，不用操心传统线程那种资源消耗大、同步处理麻烦的问题。

# 二、GMP 模型的基本架构

## 2.1 GMP 模型的核心组件

Go 语言的 GMP 模型是它实现多任务并发执行的关键，主要由三个部分组成，分别是 G（协程）、M（系统线程）和  P（处理器）。这三个组件就像工厂里的流水线一样，相互配合，让 Go 程序可以高效地处理大量并发任务，同时避免了传统多线程编程中常见的那些麻烦。

**G（协程 Goroutine）** 就是 Go 里的轻量级任务，你可以把它想象成一个个小工人。每个协程都有自己的工作状态和任务内容，存放在一个叫 G  的结构体里。和传统的线程比起来，协程占用的资源少得可怜 —— 它启动时只需要 2KB 的内存空间，而传统线程要 2MB。这种轻量级的设计让 Go 程序可以轻松创建几万个并发任务，你要创建一个协程也很简单，只需要在函数前面加个 `go` 关键字就行。

**M（系统线程 Machine）** 相当于工厂里的工作台，是真正执行任务的地方。M  和操作系统的调度器一起工作，负责安排协程的执行。一个工作台可以处理一个或多个协程，工作过程中会从本地或者全局的任务队列里找活儿干。系统里工作台的数量不是固定的，Go 运行时会根据需要调整，但最多不能超过 10000 个。

**P（处理器 Processor）**  是整个并发调度的核心，相当于工厂里的调度员，负责管理和分配任务，确保协程能在工作台上高效执行。每个调度员都有自己的本地任务队列，新创建的协程会先放到这个队列里。如果某个调度员发现自己手里没活儿干了，它会从别的调度员那里 "偷" 任务来执行，这种机制就叫 "工作窃取"。

系统里最多能同时并行执行的协程数量由调度员的数量决定，而调度员的数量可以通过设置 `GOMAXPROCS` 参数来控制，但最多不能超过 256 个，默认情况下和 CPU 的核心数一样多。（1.5版本之后其实是没有上限的，不过的话建议`GOMAXPROCS=max(1,floor(cpu_quota))`，永远不要超过你的 CPU 配额，可以看下这里 https://programmerscareer.com/zh-cn/go-25-procs/） 这意味着在多核 CPU 的机器上，Go  运行时会创建和 CPU 核心数相同的调度员，充分发挥多核的计算能力。

## 2.2 GMP 组件的交互关系

GMP 模型里这三个组件的关系就像工厂里的流水线，一环扣一环：

**M 和 P 的关系**：M 就像是工人，P 就像是工作台。工人必须坐在工作台前才能干活，而且一个工人同一时间只能坐一个工作台（1:1  绑定）。**要是工人干活时需要等待材料（系统调用阻塞），工作台不会闲着，会被推到其他空闲工人那里继续干活**，这就叫 "hand off"  机制。这样即使有工人摸鱼，工作台上的其他任务也能继续处理。

**P 和 G 的关系**：P 相当于 G 的 "工位"，每个工位最多能放 256 个任务（本地队列），还有个加急窗口（`runnext`）专门放 VIP 任务。G 必须被分配到某个工位上才能被执行，就像快递包裹必须放在分拣台上才能被处理一样。

**M 和 G 的关系**：M 是真正干活的工人，一个工人一次只能处理一个包裹（Goroutine），处理完一个就从分拣台（P 的队列）上下一个。如果分拣台上没包裹了，工人会去仓库（全局队列）或者其他分拣台偷包裹来干（工作窃取）。

**整体协作流程**：

1. 新任务（G）就像刚收到的快递，会先被扔到最近的分拣台（P 的本地队列）
2. 分拣员（P）会按顺序从队列里拿包裹，交给工人（M）处理
3. 如果工人处理某个包裹时需要等买家签收（阻塞操作），工人会把包裹放回分拣台，继续处理下一个
4. 如果某个分拣台的包裹处理完了，分拣员会去其他分拣台或者仓库找包裹来处理，保证每个工人都不闲着
5. **仓库里的包裹（全局队列）会定期分配到各个分拣台上，避免局部繁忙**

这种设计让 Go 程序可以高效利用 CPU 资源，即使有大量任务阻塞也不会影响整体吞吐量，就像一个管理高效的快递分拣中心，包裹再多也能快速处理完。

## 2.3 GMP 模型的内存管理优化

GMP 模型在内存使用上做了很多优化让有限的内存能支持大量并发任务：

### **轻量级栈**：

Goroutine 的启动门槛很低，就像共享单车，起步只要 2KB 内存（传统线程要 2MB）。这意味着同样 1GB 内存，Go 能创建 50 万个  Goroutine，而传统线程只能创建 500 个。比如一个微服务同时处理 10 万请求，Go 只需要 200MB 内存，换成传统线程要  200GB，相当于从共享单车升级到私人飞机的成本差异。

### **动态栈扩展**：（可以看一下之前的文章）

Goroutine 的栈空间就像伸缩裤腰带，需要时可以从 2KB 自动扩展到 1GB（通过 SetMaxStack 设置上限）。比如递归函数调用层级过深时，腰带会自动松开。当函数返回后，腰带又会自动收紧，释放的内存会被回收再利用，避免浪费。

### **内存分配优化**：

每个 P 都有自己的 "私房钱"（本地内存缓存  mcache），小对象（<32KB）直接从私房钱里拿，不用每次都去银行（全局分配器）排队。这样分配速度快了 10  倍，还避免了多人抢银行导致的排队锁竞争。当私房钱花完了，P 会从银行取一笔新的钱（从堆分配内存块），花不完的定期还给银行（触发垃圾回收）。

### **垃圾回收优化**：

Go 的垃圾回收器在 1.14 版本升级后学会了 "边扫边干"（抢占式调度），打扫房间**（STW 暂停）的时间控制在 1  毫秒以内**，用户几乎感觉不到。配合逃逸分析（提前规划哪些对象需要长期保存）和写屏障（记录对象变化）技术，打扫效率提升了  40%。这对需要频繁创建临时对象的分布式服务特别友好，比如电商秒杀场景，每秒创建几百万个订单对象也不会卡顿。

这种内存管理设计让 Go 特别适合云原生和分布式系统，就像一个高效的共享办公空间，能容纳大量灵活工位，按需分配资源，既节省成本又提高了空间利用率。

# 三、GMP 模型的并发机制

## 3.1 调度器的工作原理

Go 语言的调度器是 GMP 模型的核心，负责将 Goroutine 分配给 M 执行。调度器的工作原理可以分为以下几个关键部分：

**调度时机**：Go 调度器会在以下几种情况下触发调度：

- 主动调度：当 Goroutine 执行完毕、调用`runtime.Gosched()`主动让出 CPU，或者垃圾回收 STW 之后。

- 抢占式调度：当 sysmon（系统监控协程）检测到某个 Goroutine 运行时间过长（默认超过 10ms）时，会触发抢占调度。Go 1.14 引入了基于信号的异步抢占，解决了长时间 CPU 密集操作无法被抢占的问题。

- 被动调度：当 Goroutine 进行系统调用、网络 IO 操作、获取锁或 channel 操作等阻塞操作时。

**调度流程：**调度器的核心函数`schedule`就像是一个餐厅的大堂经理，专门负责给服务员分配客人（Goroutine）：

1. 经理先看 VIP 插队窗口（P 的 `runnext` 字段）有没有优先处理的客人，如果有就直接分配给空闲服务员（M）
2. 如果 VIP 窗口没人，就从本地排队区（P 的本地队列）按顺序叫号分配客人
3. 如果本地排队区也空了，经理就去中央大厅（全局队列）看看有没有客人在等
4. 如果中央大厅也没人，经理会去其他区域（其他 P 的本地队列）偷偷挖墙脚，抢几个客人过来
5. 如果所有地方都没客人，经理就会让服务员暂时休息（阻塞当前 M），直到有新客人来再叫醒他们

这个流程保证了：

- 紧急任务（`runnext`）能优先处理
- 本地任务（P 队列）能快速分配
- 全局任务（全局队列）不会被冷落
- 负载均衡（工作窃取）避免有的服务员忙死有的闲死
- 资源节约（阻塞 M）避免没事干还占着人

就像餐厅经理通过灵活调度服务员，让整个餐厅运转高效又不浪费人力，Go 的调度器通过这套流程让 CPU 资源得到最大化利用，同时避免了不必要的线程创建和切换开销。

**调度策略**：调度器采用了多种策略来确保高效的并发执行：

- **工作窃取（Work Stealing）**：就像一个团队里有多个项目组（P），当某个项目组的任务做完了（本地队列为空），组长会去其他项目组的任务清单里 "偷"  一半任务过来。而且专挑清单后面的任务偷（尾部窃取），避免影响人家正在做的工作。这样每个组员（M）都不会闲着，整体效率就提高了。比如电商大促时，订单处理组 A 处理完了自己的单子，就去订单处理组 B 那里抢一半单子过来做，避免 A 组组员摸鱼，B 组组员忙死。

- **局部性原理**：新任务就像刚到餐厅的客人，优先安排到当前服务员负责的区域（当前 P  的本地队列）。这样服务员对这片区域的桌子位置、客人需求都比较熟悉（缓存利用率高），不用满场乱跑找桌子。比如客人要点菜，服务员就在自己负责的区域内快速处理，不用跨区域找空桌，减少了无效跑动（上下文切换）。

- **公平调度**：全局队列就像餐厅的公共等待区，为了避免公共区的客人等太久，大堂经理（调度器）规定每服务 61 桌客人，必须从公共区叫一桌客人进来。这个 61  次就像一个计时器（schedtick 计数器），保证公共区的客人不会被饿死。比如周末餐厅爆满，虽然每个服务员都优先服务自己区域的客人，但每服务  61 桌后，必须从公共等待区接一桌客人，确保所有客人都能被照顾到。

## 3.2 系统调用与阻塞处理

其实这就像餐厅里服务员遇到需要长时间等待的客人（比如客人在等厨房做菜），大堂经理（调度器）会这样处理：

1. **服务员暂时离岗**：当服务员（M）遇到需要长时间等待的客人（同步系统调用）时，经理会让这个服务员暂时离开当前服务区域（P），去后台休息，这样其他服务员可以继续使用这个区域。
2. **找替代服务员**：如果有其他空闲的服务员，经理会立即让他接手这个服务区域；如果没有空闲服务员，经理会从休息区叫醒一个服务员，或者招聘一个新服务员（创建新 M）来继续服务。
3. **原服务员回归**：当厨房菜做好了（系统调用返回），原来的服务员会回来看看自己负责的区域是否还空着：
    - 如果区域还空着（P 还没被其他 M 绑定），他就继续服务这个区域的客人；
    - 如果区域已经被其他服务员占了，他就把客人的订单（Goroutine）放到公共订单池（全局队列），自己去休息区待命（M 进入休眠状态）。

这种处理方式确保了：

- 服务区域（P）不会因为某个服务员等待客人而闲置
- 其他客人（Goroutine）能继续得到服务，不会因为一个操作阻塞而全部等待
- 资源得到高效利用，等待中的服务员不会占用服务区域

就像餐厅通过灵活调度服务员，即使有客人需要长时间等待，整个餐厅的服务也不会中断，Go 的调度器通过这套机制，让即使有系统调用阻塞的情况下，整体并发性能也不会受到太大影响。

**异步阻塞处理**：对于网络 IO、channel 操作、锁获取等异步阻塞操作，处理方式有所不同：

1. 当 Goroutine 执行异步阻塞操作时，它会被标记为等待状态，并被移动到相应的等待队列（如 channel 的等待队列或网络轮询器）。

1. 当前 M 会继续执行 P 本地队列中的其他 Goroutine，不会阻塞。

1. 当阻塞条件解除（如数据到达、channel 可用或锁释放），Goroutine 会被重新放入 P 的本地队列或全局队列，等待再次调度。

**网络轮询器（Netpoller）**：Go 运行时内置了一个高效的网络轮询器，用于处理异步网络 IO。网络轮询器基于不同操作系统的 IO 多路复用机制（Linux 上的 epoll、Mac 上的 kqueue、Windows 上的 iocp）实现。当 Goroutine 进行网络 IO 操作时，Go 会将其转换为非阻塞 IO，并注册到网络轮询器中。当数据可用时，网络轮询器会将 Goroutine 重新放入可运行状态。

## 3.3 状态管理与生命周期

GMP 模型中的每个组件都有其特定的状态和生命周期，这些状态的流转构成了并发执行的基础。

**Goroutine 的状态**：Goroutine（G）有多种状态，主要包括：

- `_Gidle`：刚创建时的初始状态。

- `_Gdead`：初始化后或销毁后的状态。

- `_Grunnable`：表示 Goroutine 在运行队列中，等待被执行。

- `_Grunning`：当前 Goroutine 正在被执行。

- `_Gsyscall`：当前 Goroutine 正在执行系统调用。

- `_Gwaiting`：当前 Goroutine 正在等待某个事件（如 channel 操作、锁获取等）。

**Goroutine 的生命周期流转**：

1. 新建 Goroutine → _Gidle → 初始化 → _Grunnable。

1. _Grunnable → 开始运行 → _Grunning → 运行完成 → _Gdead。

1. _Grunning → 阻塞（如 channel 操作）→ _Gwaiting → 被唤醒 → _Grunnable。

1. _Grunning → 进入系统调用 → _Gsyscall → 系统调用返回 → _Grunnable或_Gwaiting。

**Processor 的状态**：Processor（P）也有多种状态，包括：

- `_Pidle`：P 未被使用，本地队列为空，等待任务。

- `_Prunning`：P 正在正常运行，绑定到一个 M，执行用户代码。

- `_Psyscall`：P 绑定的 M 正在执行系统调用，此时 P 不执行用户代码。

- `_Pgcstop`：P 在垃圾回收期间被暂停。

**Machine 的状态**：Machine（M）的状态主要包括运行、休眠、自旋等。M 的数量由 Go 运行时自动调整，以平衡系统负载和资源使用。

# 四、GMP 模型的分布式视角分析

## 4.1 分布式系统中的并发挑战

分布式系统里的并发问题，跟单台机器上的情况比，差别大得多。搞懂这些问题，对设计好用的分布式系统特别重要。

**资源管理更麻烦**：分布式系统里，资源分散在好多节点上 —— 就像一堆东西分别放在不同的仓库里。想高效管这些分散的资源不容易，以前单台机器上用的 “锁” 在这不好使了。得用更复杂的协调规则（比如分布式一致性协议），才能让各个节点对资源的使用达成一致。

**数据得保持一致**：多节点可能同时改同一个数据 —— 比如好几个分店同时更新总库存。怎么让改完之后大家看到的数据都一样，是个核心问题。Go 语言的并发机制在单台机器上能管好本地的并发，但跨节点改数据时，得靠专门的算法（像 Raft、Paxos 这些）才能保证数据一致。

**网络不靠谱**：节点之间靠网络通信，但网络慢、断连是常有的事。就像远程团队靠电话沟通，时不时信号不好或掉线。在这种不稳定的情况下，还得让系统高效处理并发任务，是设计时要解决的关键难题。

**任务得分配均匀**：分布式系统里，任务和压力分散在多个节点上。得想办法让这些任务动态分配均匀，别让有的节点忙得要死，有的却闲着 —— 就像分活儿给一群人，不能让几个人累死，其他人没事干。这才能让整个系统的性能提上去。

## 4.2 GMP 模型对分布式系统的支撑作用

尽管 GMP 模型本身是为单机并发设计的，但其特性为构建高效的分布式系统提供了有力支撑。

**轻量级并发单元**：
Goroutine 的轻量级特性使得分布式系统可以轻松处理海量并发请求。单个 Go 程序可同时运行数百万个 Goroutine，这种设计使得分布式系统能够高效处理海量并发请求。

**高效的调度机制**：
GMP 调度器的工作窃取算法和本地队列设计，使得 Go 程序在多核处理器上能够实现高效的负载均衡。测试数据显示，在 8 核服务器上 Go 调度器的上下文切换耗时仅为 0.2μs，显著低于操作系统线程切换的 1-2μs。

**内存管理优化**：
Go 的垃圾回收器经过多次迭代，在 1.14 版本引入的抢占式调度机制将 STW 时间控制在 1ms 以内。这种特性特别适合需要频繁创建临时对象的分布式服务场景。

**CSP 模型与消息传递**：
Go 语言的 CSP（通信顺序进程）模型通过 channel 进行数据传递而非共享内存，有效避免了传统多线程编程中的竞态条件。这种设计理念与分布式系统中推荐的无共享架构（shared-nothing architecture）高度契合。

这些特性使得 Go 语言在分布式系统开发中具有显著优势，能够高效地处理海量并发请求、优化资源利用、减少系统延迟，并提供可靠的并发编程模型。

## 4.3 Go 在分布式系统中的典型应用场景

Go 语言的并发模型在分布式系统里有不少典型的应用场景，下面具体说说几种：

**微服务间通信的并发控制**：
在服务网格这种架构里，Go 语言的 gRPC 实现靠每个连接单独的 Goroutine 池来处理双向的流式通信。就拿 Istio 1.7 版本来说，实际测试显示，用 Go 写的 Envoy 过滤器比 C++ 版本省了 30% 的内存，吞吐量却差不多。而且在连接池管理中，用 sync.Pool 来复用对象，让  TCP 连接的复用率能到 92% 以上，效率很高。

**分布式任务调度与协调**：
像 Cadence、Temporal 这些用 Go 开发的分布式任务调度系统，借助 channel  实现了任务队列的背压控制。比如在双十一大促时，有个电商平台用 Go 重写了调度系统，之后任务派发的延迟从 150 毫秒降到了 35  毫秒，错误重试的成功率也提到了 99.99%，效果很明显。

**分布式一致性协议实现**：
像 etcd 里的 raft 模块这种用 Go 实现的 Raft 共识算法，通过 Goroutine 来划分角色状态机，让 Leader  选举、日志复制、状态提交这些流程能并行处理。测试发现，在 3 个节点的集群里，用 Go 实现的 Raft 协议处理 10  万次写请求的时间，只相当于 Java 实现的 65%，内存碎片率还降低了 40%。

**分布式监控与追踪**：
Go 语言的并发模型很适合做分布式监控和追踪系统。收集、处理、上报每个监控指标的操作，都能放在单独的 Goroutine 里运行，互相不影响，这样就保证了监控系统又高效又可靠。

## 4.4 分布式系统中的并发模式与最佳实践

在分布式系统里用Go语言搞并发编程，得遵循一些特定的模式和靠谱的做法。

**Actor模型的应用**： Actor模型是种适合分布式系统的并发计算模型，每个Actor都管好自己的状态，靠发消息来通信。在Go里，能用goroutine加channel来模拟这个模型。这种模式尤其适合高并发、分布式系统、状态机建模这类场景。

**负载均衡策略**： 分布式系统里，一般得搞个负载均衡策略，把任务均匀分到多个节点上。Go的并发模型支持好几种负载均衡策略，像轮询、随机、最少连接这些，能根据具体情况挑合适的用。

**容错与恢复机制**： 分布式系统里，节点和网络出故障是常有的事，得设计有效的容错和恢复机制。Go的defer和panic/recover机制能帮忙实现得体的错误处理和恢复逻辑。 **分布式锁与协调**： 在需要全局一致的场景里，分布式锁是常用的协调办法。Go的sync.Mutex和sync.RWMutex提供了高效的本地锁机制，而在分布式环境下，能结合etcd、Consul这些分布式键值存储来实现分布式锁。

**背压控制**： 分布式系统中，处理能力不匹配是常见问题，得实现背压控制机制来避免系统过载。Go的channel能方便地实现简单的背压控制，比如通过限制channel的缓冲区大小来控制发送方的速度。

# 五、GMP 模型的演进与优化

## 5.1 GMP 模型的历史演进

GMP 模型不是一下子就做成现在这样的，而是经过了好几次改进和优化。

**GM 模型（Go 1.0 之前）**：
Go 语言一开始用的是 GM 模型，里面 G 代表协程，M 代表系统线程。这种模型有个全局锁的问题，所有协程的调度都得先拿到这个全局锁，导致在多核机器上跑的时候，性能上不去，成了瓶颈。

**GMP 模型的引入（Go 1.1）**：
为了解决 GM 模型的全局锁问题，Go 团队在 1.1 版本里加了个 Processor（P）结构，这就有了现在的 GMP 模型。P 的加入让调度工作能在多个 P 之间同时进行，大大减少了抢锁的情况，多核的利用率也提高了。

**抢占式调度的改进**：
Go 早期版本只支持协作式抢占，意思是协程得自己主动把 CPU 让出来。这种方式在那种一直占着 CPU 算个不停的任务里效率很低，因为一个协程可能长时间霸占 CPU 不放。Go 1.14 版本加了基于信号的异步抢占，这才解决了这个问题。

**系统监控器（sysmon）的优化**：
sysmon 是 Go 运行时里一个特殊的协程，负责盯着 M 的状态并进行管理。对 sysmon 的优化让 Go 调度器能更高效地发现和处理那些跑了很久的协程，系统的响应速度也进一步提升了。

## 5.2 现代 GMP 模型的优化策略

> 这些上面都提到了不少，这里补充下

现在的 GMP 模型用了不少优化手段，来提升并发性能和资源利用率。

**工作窃取算法的优化**：
现在的 GMP 模型里，工作窃取算法经过好几次优化，比如采用随机选目标的窃取策略，还能动态调整每次偷多少任务。这些优化让负载分配更均匀高效，减少了线程之间的争抢。

**本地队列的优化**：
每个 P 都有自己的本地运行队列，新创建的 Goroutine 优先放进本地队列。这种设计减少了不同 P 之间的竞争，缓存的利用效率也更高。另外，P 还专门有个 runnext 字段，存着下一个要优先执行的 Goroutine，进一步增强了任务执行的局部性。

**网络轮询器的优化**：
Go 的网络轮询器（netpoller）下了不少功夫优化，能高效处理大量并发的网络连接。它是基于操作系统里高效的 IO 多路复用机制来实现的，比如 Linux 上用 epoll，Mac 上用 kqueue，Windows 上用 iocp。

**内存分配的优化**：
Go 的内存分配器（mcache、mcentral、mheap）用了多级缓存的设计，减少了锁的竞争，让内存分配更快。每个 P 都有自己的本地内存缓存（mcache），大多数时候分配内存直接在本地就能完成，不用去抢全局锁。

**垃圾回收的优化**：
Go 的垃圾回收器经过多次升级，最新版本用了并发标记 - 清除算法，大大缩短了 STW（暂停整个世界）的时间。Go 1.14 引入的混合写屏障技术，进一步优化了垃圾回收的性能，让并发内存分配的效率提升了 40% 以上。

# 六、结论

GMP 模型的核心价值在于它能高效处理并发，而且执行单元特别轻巧。Goroutine、Machine 和 Processor  这三个核心部分配合工作，让 Go 语言能轻松管好成千上万的并发任务，不用像传统线程模型那样，既要担心资源消耗太大，又要处理复杂的同步问题。GMP 模型的并发机制靠的是高效的调度器，里面用到了工作窃取算法、本地队列、抢占式调度这些手段。这些机制能让 Go 程序充分发挥多核处理器的性能，把并发处理做得又快又好。从分布式的角度来看，GMP 模型的轻量级并发单元、高效的调度机制和优化的内存管理，给搭建高效的分布式系统帮了大忙。Go 语言在微服务架构、分布式任务调度、分布式一致性协议实现这些领域都用得很多。虽然现在的 GMP 模型已经挺成熟高效了，但还在一直改进优化。以后的 GMP 模型可能会加入更智能的调度算法、更好的资源隔离机制，对分布式的支持也会更完善，让 Go 语言的并发性能更强，能用的地方也更广。

总的来说，搞懂 GMP 模型的并发机制和架构设计，对写出高效的 Go 程序、搭建可扩展的分布式系统都特别重要。随着云计算和分布式系统不断发展，Go 语言和它的 GMP 模型在未来的软件开发中肯定会更重要。